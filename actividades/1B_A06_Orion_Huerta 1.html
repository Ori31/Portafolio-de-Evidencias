<!-- Estructura básica del documento HTML -->
<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Calculadora Expresiones Algebraicas</title>
     <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Tiny5&display=swap" rel="stylesheet">
    <style>
    /* ==================== VARIABLES DE COLOR ==================== */
    :root {
        --main-bg: #0a0a12;
        --secondary-bg: #151520;
        --accent-blue: #00a8f3;
        --accent-purple: #8a2be2;
        --accent-pink: #ff00ff;
        --text-primary: #e0e0ff;
        --text-secondary: #a0a0c0;
        --border-glow: rgba(0, 168, 243, 0.3);
        --terminal-green: #00ff00;

        /* Colores del estilo anterior para la fusión */
        --dark-violet: rgb(71, 8, 129);
        --bright-turquoise: turquoise;
    }

    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    /* ==================== FONDO Y FUENTE GENERAL ==================== */
    body {
        font-family: "Courier New", "Monaco", monospace;
        line-height: 1.6;
        color: var(--text-primary);
        background-color: var(--main-bg);
        /* Manteniendo el patrón de fondo ciberpunk */
        background-image:
            radial-gradient(
                circle at 10% 20%,
                rgba(138, 43, 226, 0.05) 0%,
                transparent 20%
            ),
            radial-gradient(
                circle at 90% 80%,
                rgba(0, 168, 243, 0.05) 0%,
                transparent 20%
            );
        min-height: 100vh;
    }

    body::after {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(
            0deg,
            rgba(0, 0, 0, 0.15) 0px,
            rgba(0, 0, 0, 0.15) 1px,
            transparent 1px,
            transparent 2px
        );
        pointer-events: none;
        z-index: 100;
    }

    /* ==================== ENCABEZADO Y TÍTULOS ==================== */
    header {
        background-color: rgba(10, 10, 18, 0.9);
        color: var(--text-primary);
        text-align: center;
        padding: 2rem 1rem;
        /* Usando el color violeta oscuro y turquesa del estilo anterior para el glow */
        border-bottom: 1px solid var(--bright-turquoise);
        box-shadow: 0 0 15px var(--dark-violet);
        position: relative;
        overflow: hidden;
    }

    header::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 2px;
        background: linear-gradient(
            90deg,
            transparent,
            var(--bright-turquoise),
            transparent
        );
        animation: scanline 3s linear infinite;
    }

    @keyframes scanline {
        0% {
            left: -100%;
        }
        100% {
            left: 100%;
        }
    }

    header h1 {
        /* Estilo de h1 del CSS anterior (más grande, color violeta) */
        font-size: 3.5rem; /* Ajustado para que quepa bien */
        font-weight: 700;
        margin-bottom: 0.5rem;
        color: var(--dark-violet);
        text-shadow: 0 0 15px var(--dark-violet), 0 0 5px var(--bright-turquoise);
        letter-spacing: 2px;
        font-family: 'Tiny5', sans-serif; /* Fuente del estilo anterior */
    }

    .subtitle {
        /* Estilo de p/h3 del CSS anterior (color turquesa) */
        font-size: 1.5rem;
        color: var(--bright-turquoise);
        text-shadow: 0 0 8px var(--bright-turquoise);
        font-family: 'Tiny5', sans-serif; /* Fuente del estilo anterior */
    }

    .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem 1rem;
        display: flex;
        flex-direction: column;
        gap: 2rem;
    }

    /* Títulos de columnas y secciones */
    .column h2,
    .json-loader-section h2,
    .info-section h2,
    .history-section h2 {
        /* Unificando títulos con el color turquesa del estilo anterior */
        color: var(--bright-turquoise);
        font-size: 1.8rem;
        margin-bottom: 1rem;
        text-align: center;
        border-bottom: 1px solid var(--dark-violet);
        padding-bottom: 0.5rem;
        text-shadow: 0 0 8px var(--bright-turquoise);
        font-family: 'Tiny5', sans-serif; /* Fuente del estilo anterior */
    }


    /* ==================== COLUMNAS Y FORMULARIOS ==================== */
    .converter-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 2rem;
    }

    .column {
        background-color: var(--secondary-bg);
        border: 2px solid var(--dark-violet); /* Borde violeta */
        border-radius: 25px; /* Más redondeado como el CSS anterior */
        padding: 1.5rem;
        box-shadow: 0 0 15px rgba(71, 8, 129, 0.5); /* Sombra violeta */
        transition: all 0.3s ease;
        position: relative;
    }

    .column:hover {
        box-shadow: 0 0 20px var(--bright-turquoise); /* Glow turquesa al pasar el ratón */
        border-color: var(--bright-turquoise);
    }

    .input-group label {
        display: block;
        color: var(--bright-turquoise); /* Etiquetas en turquesa */
        font-weight: 600;
        margin-bottom: 0.5rem;
        text-shadow: 0 0 5px var(--dark-violet);
        font-family: 'Tiny5', sans-serif;
        font-size: 1.1rem;
    }

    textarea {
        width: 100%;
        padding: 0.75rem;
        border: 1px solid var(--dark-violet);
        border-radius: 8px;
        font-size: 1rem;
        font-family: inherit;
        resize: vertical;
        transition: all 0.3s ease;
        background-color: rgba(0, 0, 0, 0.5);
        color: var(--text-primary);
        box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.7);
    }

    textarea:focus {
        outline: none;
        border-color: var(--bright-turquoise);
        box-shadow:
          0 0 10px var(--bright-turquoise),
          inset 0 0 5px rgba(0, 0, 0, 0.5);
    }

    /* ==================== BOTONES DE CONVERSIÓN ==================== */
    .convert-button {
        width: 100%;
        background: linear-gradient(to bottom, var(--dark-violet), #000);
        color: var(--bright-turquoise);
        border: 2px solid var(--bright-turquoise);
        padding: 1rem 1rem;
        border-radius: 10px;
        font-size: 1.2rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        text-shadow: 0 0 10px currentColor;
        position: relative;
        overflow: hidden;
        font-family: 'Tiny5', sans-serif;
    }

    .convert-button:hover {
        background: linear-gradient(to bottom, #000, var(--dark-violet));
        box-shadow: 0 0 20px var(--bright-turquoise);
        text-shadow: 0 0 15px currentColor;
    }

    /* ==================== RESULTADOS ==================== */
    .result-section {
        margin-top: 1.5rem;
        padding-top: 1rem;
        border-top: 1px solid var(--dark-violet);
    }

    .result-content h4 {
        color: var(--bright-turquoise);
        margin-bottom: 0.5rem;
        font-size: 1.2rem;
        text-shadow: 0 0 5px currentColor;
        font-family: 'Tiny5', sans-serif;
    }

    .result-output {
        /* Fondo de resultado similar al anterior (oscuridad profunda) */
        background-color: rgba(0, 0, 0, 0.7);
        border: 1px solid var(--bright-turquoise);
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
        font-family: "Courier New", monospace;
        font-size: 1.2rem;
        min-height: 60px;
        color: var(--terminal-green);
        text-shadow: 0 0 5px currentColor;
        box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.3);
    }

    /* ==================== BOTONES DE ACCIÓN (Evaluación, Carga, Historia) ==================== */

    /* Botones de Evaluación */
    .satisfactory-btn,
    .improve-btn,
    .add-pattern-btn {
        background: linear-gradient(to bottom, var(--secondary-bg), #000);
        color: var(--text-primary);
        padding: 0.5rem 0.75rem;
        border-radius: 4px;
        font-size: 0.9rem;
        cursor: pointer;
        flex: 1;
        min-width: 120px;
        transition: all 0.3s ease;
        text-shadow: 0 0 3px currentColor;
        font-weight: bold;
    }

    .satisfactory-btn {
        border: 1px solid #10b981;
    }

    .satisfactory-btn:hover {
        box-shadow: 0 0 10px #10b981;
    }

    .improve-btn {
        border: 1px solid var(--accent-purple);
    }

    .improve-btn:hover {
        box-shadow: 0 0 10px var(--accent-purple);
    }

    .add-pattern-btn {
        border: 1px solid var(--accent-blue);
    }

    .add-pattern-btn:hover {
        box-shadow: 0 0 10px var(--accent-blue);
    }


    /* Botones de Carga/Reset */
    .file-input-label,
    .load-button,
    .reset-button {
        background: linear-gradient(to bottom, var(--secondary-bg), #000);
        color: var(--text-primary);
        padding: 0.5rem 1rem;
        border-radius: 2px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.3s ease;
        text-shadow: 0 0 3px currentColor;
    }

    .file-input-label {
        border: 1px solid var(--dark-violet); /* Etiqueta de archivo con borde violeta */
    }

    .file-input-label:hover {
        box-shadow: 0 0 10px var(--dark-violet);
        border-color: var(--accent-pink);
    }

    .load-button {
        border: 1px solid var(--bright-turquoise); /* Botón de carga con borde turquesa */
    }

    .load-button:hover:not(:disabled) {
        box-shadow: 0 0 10px var(--bright-turquoise);
    }

    .reset-button {
        border: 1px solid var(--accent-purple);
    }

    .reset-button:hover {
        box-shadow: 0 0 10px var(--accent-purple);
        border-color: var(--accent-pink);
    }

    /* ==================== SECCIONES DE INFORMACIÓN E HISTORIAL ==================== */
    .json-loader-section,
    .info-section,
    .history-section {
        background-color: var(--secondary-bg);
        border: 2px solid var(--dark-violet);
        border-radius: 25px; /* Más redondeado */
        padding: 1.5rem;
        box-shadow: 0 0 15px rgba(71, 8, 129, 0.5);
    }

    .info-card {
        background: linear-gradient(
            to bottom,
            rgba(0, 0, 0, 0.3),
            var(--secondary-bg)
        );
        border: 1px solid var(--bright-turquoise); /* Borde turquesa */
        border-radius: 8px;
        padding: 1rem;
        text-align: center;
        transition: all 0.3s ease;
    }

    .info-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 0 15px var(--bright-turquoise);
        border-color: var(--accent-blue);
    }

    .metric-number {
        font-size: 2rem;
        font-weight: 700;
        color: var(--terminal-green);
        text-shadow: 0 0 8px var(--terminal-green);
    }

    .metric-label {
        color: var(--bright-turquoise); /* Etiquetas en turquesa */
    }


    .history-list {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid var(--bright-turquoise);
        border-radius: 8px;
        padding: 1rem;
        background-color: rgba(0, 0, 0, 0.7);
        box-shadow: inset 0 0 10px rgba(0, 191, 255, 0.3);
    }


    .clear-button,
    .export-button {
        padding: 0.5rem 1rem;
        border-radius: 4px;
        border: 1px solid;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        background: linear-gradient(to bottom, var(--secondary-bg), #000);
        color: var(--text-primary);
        text-shadow: 0 0 3px currentColor;
    }

    .clear-button {
        border-color: #ff4444;
    }

    .export-button {
        border-color: var(--bright-turquoise);
    }

    /* ==================== PIE DE PÁGINA ==================== */
    footer {
        background-color: rgba(10, 10, 18, 0.9);
        color: var(--text-primary);
        text-align: center;
        padding: 1.5rem;
        margin-top: 2rem;
        border-top: 1px solid var(--bright-turquoise);
        box-shadow: 0 0 15px var(--dark-violet);
    }

    footer p {
        color: var(--text-secondary);
        font-family: 'Tiny5', sans-serif;
    }

    /* MANTENER MEDIA QUERIES EXISTENTES */
    @media (max-width: 768px) {
        .converter-grid {
            grid-template-columns: 1fr;
        }

        header h1 {
            font-size: 2.5rem;
        }

        .subtitle {
            font-size: 1.2rem;
        }

        .container {
            padding: 1rem;
        }

        .json-loader {
            flex-direction: column;
            align-items: stretch;
        }

        .info-cards {
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        }

        .history-controls {
            flex-direction: column;
        }
    }

    @media (max-width: 480px) {
        .info-cards {
            grid-template-columns: 1fr;
        }
    }
</style>
  </head>
  <body>
    <!-- Encabezado principal -->
    <header>
      <h1>Calculadora de Expresiones</h1>
      <p class="subtitle">
        Convierte entre lenguaje natural y expresiones algebraicas
      </p>
    </header>

    <!-- Contenedor principal de 2 columnas -->
    <main class="container">
      <div class="converter-grid">
        <!-- Columna izquierda: Lenguaje Natural -->
        <div class="column natural-column">
          <h2>Lenguaje Natural</h2>
          <div class="input-group">
            <label for="natural-input"
              >Escribe en palabras tu expresión matemática</label
            >
            <textarea
              id="natural-input"
              placeholder="Ejemplo: La suma de de a y b"
              rows="5"
            ></textarea>
          </div>
          <button id="convert-to-algebraic-btn" class="convert-button">
            Convertir a Expresión Algebraica
          </button>
          <!-- En la columna natural, después del botón convert-to-algebraic-btn -->
          <div id="natural-result" class="result-section" style="display: none">
            <div class="result-content">
              <h4>Resultado:</h4>
              <div id="natural-output" class="result-output"></div>
            </div>
            <div class="evaluation-buttons">
              <button id="natural-satisfactory-btn" class="satisfactory-btn">
                Resultado Satisfactorio
              </button>
              <button id="natural-improve-btn" class="improve-btn">
                Necesita Mejora
              </button>
              <button id="natural-add-pattern-btn" class="add-pattern-btn">
                Agregar Patrón
              </button>
            </div>
          </div>
        </div>

        <!-- Columna derecha: Expresión Algebraica -->
        <div class="column algebraic-column">
          <h2>Expresión Algebraica</h2>
          <div class="input-group">
            <label for="algebraic-input">Escribe tu expresión matemática</label>
            <textarea
              id="algebraic-input"
              placeholder="Ejemplo: a^2 + b^2"
              rows="5"
            ></textarea>
          </div>
          <button id="convert-to-natural-btn" class="convert-button">
            Convertir a Lenguaje Natural
          </button>
          <!-- En la columna algebraica, después del botón convert-to-natural-btn -->
          <div
            id="algebraic-result"
            class="result-section"
            style="display: none"
          >
            <div class="result-content">
              <h4>Resultado:</h4>
              <div id="algebraic-output" class="result-output"></div>
            </div>
            <div class="evaluation-buttons">
              <button id="algebraic-satisfactory-btn" class="satisfactory-btn">
                Resultado Satisfactorio
              </button>
              <button id="algebraic-improve-btn" class="improve-btn">
                Necesita Mejora
              </button>
              <button id="algebraic-add-pattern-btn" class="add-pattern-btn">
                Agregar Patrón
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Sección de carga de JSON -->
      <section class="json-loader-section">
        <h2>Base de Datos de Patrones</h2>
        <div class="json-loader">
          <div class="file-input-wrapper">
            <input type="file" id="json-file-input" accept=".json" />
            <label for="json-file-input" class="file-input-label">
              Cargar archivo JSON
            </label>
            <span id="file-name" class="file-name"
              >Ningún archivo seleccionado</span
            >
          </div>
          <button id="load-json-btn" class="load-button" disabled>
            Cargar Patrones
          </button>
          <button id="reset-json-btn" class="reset-button">
            Usar Patrones por Defecto
          </button>
        </div>
      </section>

      <!-- Tarjeta de información y métricas -->
      <section class="info-section">
        <h2>Información del Sistema</h2>
        <div class="info-cards">
          <div class="info-card">
            <h3>Patrones Cargados</h3>
            <div class="metric">
              <span class="metric-number" id="total-patterns">0</span>
              <span class="metric-label">expresiones disponibles</span>
            </div>
          </div>

          <div class="info-card">
            <h3>Archivo JSON</h3>
            <div class="metric">
              <span class="metric-number" id="file-size">0 KB</span>
              <span class="metric-label">tamaño del archivo</span>
            </div>
          </div>

          <div class="info-card">
            <h3>Conversiones</h3>
            <div class="metric">
              <span class="metric-number" id="conversions-count">0</span>
              <span class="metric-label">conversiones realizadas</span>
            </div>
          </div>

          <div class="info-card">
            <h3>Tasa de Satisfacción</h3>
            <div class="metric">
              <span class="metric-number" id="satisfaction-rate">0%</span>
              <span class="metric-label">conversiones satisfactorias</span>
            </div>
          </div>

          <div class="info-card">
            <h3>Última Actualización</h3>
            <div class="metric">
              <span class="metric-number" id="last-update">--</span>
              <span class="metric-label">patrones modificados</span>
            </div>
          </div>

          <div class="info-card">
            <h3>Complejidad Promedio</h3>
            <div class="metric">
              <span class="metric-number" id="avg-complexity">0</span>
              <span class="metric-label">palabras por expresión</span>
            </div>
          </div>
        </div>
      </section>

      <!-- Sección de historial de conversiones -->
      <section class="history-section">
        <h2>Historial de Conversiones</h2>
        <div class="history-controls">
          <button id="clear-history-btn" class="clear-button">
            Limpiar Historial
          </button>
          <button id="export-history-btn" class="export-button">
            Exportar Historial
          </button>
        </div>
        <div id="conversion-history" class="history-list">
          <p class="no-history">No hay conversiones realizadas aún</p>
        </div>
      </section>
    </main>

    <!-- Pie de página -->
    <footer>
      <p>
        Proyecto desarrollado para estudiantes del TSU en Desarrollo de Software
        y Negocios Digitales
      </p>
      <p>Tecnológico de Software - Primer Cuatrimestre 2025</p>
    </footer>
    <script>
      // ...existing code...

      // Inicialización cuando se carga la página
      document.addEventListener("DOMContentLoaded", function () {
        // Cargar patrones por defecto
        loadPatterns(defaultPatterns);

        // Configurar event listeners
        setupEventListeners();

        // Actualizar métricas iniciales
        updateMetrics();
      });

      // Configurar todos los event listeners
      function setupEventListeners() {
        // Botones de conversión
        document
          .getElementById("convert-to-algebraic-btn")
          .addEventListener("click", () => {
            convertNaturalToAlgebraic();
          });

        document
          .getElementById("convert-to-natural-btn")
          .addEventListener("click", () => {
            convertAlgebraicToNatural();
          });

        // Botones de evaluación - Columna Natural
        document
          .getElementById("natural-satisfactory-btn")
          .addEventListener("click", () => {
            markAsSatisfactory("natural");
          });

        document
          .getElementById("natural-improve-btn")
          .addEventListener("click", () => {
            markForImprovement("natural");
          });

        document
          .getElementById("natural-add-pattern-btn")
          .addEventListener("click", () => {
            showAddPatternDialog("natural");
          });

        // Botones de evaluación - Columna Algebraica
        document
          .getElementById("algebraic-satisfactory-btn")
          .addEventListener("click", () => {
            markAsSatisfactory("algebraic");
          });

        document
          .getElementById("algebraic-improve-btn")
          .addEventListener("click", () => {
            markForImprovement("algebraic");
          });

        document
          .getElementById("algebraic-add-pattern-btn")
          .addEventListener("click", () => {
            showAddPatternDialog("algebraic");
          });

        // Manejo de archivos JSON
        document
          .getElementById("json-file-input")
          .addEventListener("change", handleFileSelection);
        document
          .getElementById("load-json-btn")
          .addEventListener("click", loadJSONFile);
        document
          .getElementById("reset-json-btn")
          .addEventListener("click", resetToDefault);

        // Historial
        document
          .getElementById("clear-history-btn")
          .addEventListener("click", clearHistory);
        document
          .getElementById("export-history-btn")
          .addEventListener("click", exportHistory);
      }

      // Función para convertir lenguaje natural a algebraico
      function convertNaturalToAlgebraic() {
        const input = document.getElementById("natural-input").value.trim();
        if (!input) {
          alert("Por favor, ingresa una expresión en lenguaje natural");
          return;
        }

        const result = processNaturalToAlgebraic(input);
        displayResult("natural", input, result);

        // Actualizar estadísticas
        stats.totalConversions++;
        addToHistory("natural-to-algebraic", input, result);
        updateMetrics();
      }

      // Función para convertir algebraico a lenguaje natural
      function convertAlgebraicToNatural() {
        const input = document.getElementById("algebraic-input").value.trim();
        if (!input) {
          alert("Por favor, ingresa una expresión algebraica");
          return;
        }

        const result = processAlgebraicToNatural(input);
        displayResult("algebraic", input, result);

        // Actualizar estadísticas
        stats.totalConversions++;
        addToHistory("algebraic-to-natural", input, result);
        updateMetrics();
      }

      // Procesar conversión de natural a algebraico
      function processNaturalToAlgebraic(input) {
        if (!patternsData || !patternsData.patterns) {
          return "Error: No hay patrones cargados";
        }

        const normalizedInput = input.toLowerCase();

        // Buscar patrones que coincidan
        for (let pattern of patternsData.patterns) {
          const match = matchNaturalPattern(normalizedInput, pattern.natural);
          if (match.isMatch) {
            return substituteVariables(pattern.algebraic, match.variables);
          }
        }

        return "No se encontró un patrón coincidente. Considera agregar este caso a los patrones.";
      }

      // Procesar conversión de algebraico a natural
      function processAlgebraicToNatural(input) {
        if (!patternsData || !patternsData.patterns) {
          return "Error: No hay patrones cargados";
        }

        const normalizedInput = normalizeAlgebraicExpression(input);

        // Buscar patrones que coincidan
        for (let pattern of patternsData.patterns) {
          const match = matchAlgebraicPattern(
            normalizedInput,
            pattern.algebraic
          );
          if (match.isMatch) {
            return substituteVariables(pattern.natural, match.variables);
          }
        }

        return "No se encontró un patrón coincidente. Considera agregar este caso a los patrones.";
      }

      // Función para hacer coincidir patrones de lenguaje natural
      function matchNaturalPattern(input, pattern) {
        // Convertir patrón a regex
        let regex = pattern.toLowerCase();
        const variables = {};
        let varCounter = 0;

        // Reemplazar variables con grupos de captura
        regex = regex.replace(/\{(\w+)\}/g, (match, varName) => {
          variables[varName] = varCounter++;
          return "([a-zA-Z0-9_]+)";
        });

        // Hacer que los espacios sean opcionales y flexibles
        regex = regex.replace(/\s+/g, "\\s*");
        regex = "^\\s*" + regex + "\\s*$";

        const regexPattern = new RegExp(regex);
        const match = input.match(regexPattern);

        if (match) {
          const extractedVars = {};
          for (let [varName, index] of Object.entries(variables)) {
            extractedVars[varName] = match[index + 1];
          }
          return { isMatch: true, variables: extractedVars };
        }

        return { isMatch: false, variables: {} };
      }

      function matchAlgebraicPattern(input, pattern) {
        let normalizedInput = normalizeAlgebraicExpression(input);
        let normalizedPattern = normalizeAlgebraicExpression(pattern);

        console.log("=== DEBUGGING MATCH ===");
        console.log("Pattern original:", pattern);
        console.log("Pattern normalizado:", normalizedPattern);
        console.log("Input normalizado:", normalizedInput);

        // Primero escapar caracteres especiales EXCEPTO las llaves
        let regex = normalizedPattern.replace(/[\+\-\*\^]/g, "\\$&");
        console.log("Después de escapar:", regex);

        // Luego reemplazar variables con grupos de captura
        const variables = {};
        let varCounter = 0;

        regex = regex.replace(/\{(\w+)\}/g, (match, varName) => {
          variables[varName] = varCounter++;
          console.log(
            `Variable encontrada: ${varName} en posición ${varCounter - 1}`
          );
          return "([a-zA-Z0-9_]+)";
        });

        regex = "^\\s*" + regex + "\\s*$";

        console.log("Regex final:", regex);
        console.log("Variables mapeadas:", variables);

        const regexPattern = new RegExp(regex);
        const match = normalizedInput.match(regexPattern);

        console.log("Match result:", match);
        console.log("=== END DEBUG ===");

        if (match) {
          const extractedVars = {};
          for (let [varName, index] of Object.entries(variables)) {
            extractedVars[varName] = match[index + 1];
          }
          return { isMatch: true, variables: extractedVars };
        }

        return { isMatch: false, variables: {} };
      }

      // Normalizar expresiones algebraicas
      function normalizeAlgebraicExpression(expr) {
        return expr
          .replace(/\s+/g, "") // Quitar espacios
          .replace(/²/g, "^2") // Convertir ² a ^2
          .replace(/³/g, "^3") // Convertir ³ a ^3
          .replace(/\*/g, "×") // Normalizar multiplicación
          .replace(/\//g, "÷") // Normalizar división
          .toLowerCase();
      }

      // Sustituir variables en el patrón
      function substituteVariables(template, variables) {
        let result = template;
        for (let [varName, value] of Object.entries(variables)) {
          const regex = new RegExp(`\\{${varName}\\}`, "g");
          result = result.replace(regex, value);
        }
        return result;
      }

      // Mostrar resultado en la interfaz
      function displayResult(column, input, result) {
        const resultSection = document.getElementById(`${column}-result`);
        const outputElement = document.getElementById(`${column}-output`);

        outputElement.textContent = result;
        resultSection.style.display = "block";
      }

      // Marcar como satisfactorio
      function markAsSatisfactory(column) {
        stats.satisfactoryConversions++;
        updateMetrics();

        // Feedback visual
        showFeedback(`Marcado como satisfactorio`, "success");

        // Ocultar la sección de resultado después de un tiempo
        setTimeout(() => {
          document.getElementById(`${column}-result`).style.display = "none";
        }, 2000);
      }

      // Marcar para mejora
      function markForImprovement(column) {
        showFeedback(
          "Marcado para mejora. Considera agregar un nuevo patrón.",
          "warning"
        );
      }

      // Mostrar diálogo para agregar patrón
      function showAddPatternDialog(column) {
        const input = document.getElementById(
          `${column === "natural" ? "natural" : "algebraic"}-input`
        ).value;
        const output = document.getElementById(`${column}-output`).textContent;

        const naturalText = column === "natural" ? input : output;
        const algebraicText = column === "natural" ? output : input;

        const newNatural = prompt(
          "Expresión en lenguaje natural:",
          naturalText
        );
        if (!newNatural) return;

        const newAlgebraic = prompt("Expresión algebraica:", algebraicText);
        if (!newAlgebraic) return;

        const category =
          prompt("Categoría (opcional):", "personalizado") || "personalizado";

        addNewPattern(newNatural, newAlgebraic, category);
      }
      // Variables globales
      let patternsData = null;
      let conversionHistory = [];
      let stats = {
        totalConversions: 0,
        satisfactoryConversions: 0,
        totalPatterns: 0,
        fileSize: 0,
        lastUpdate: null,
      };

      // Patrones por defecto para comenzar
      const defaultPatterns = {
        patterns: [
          {
            id: 1,
            natural: "La suma de {var1} y {var2}",
            algebraic: "{var1} + {var2}",
            category: "operaciones_basicas",
          },
          {
            id: 2,
            natural: "La resta de {var1} y {var2}",
            algebraic: "{var1} - {var2}",
            category: "operaciones_basicas",
          },
          {
            id: 3,
            natural: "El producto de {var1} por {var2}",
            algebraic: "{var1} × {var2}",
            category: "operaciones_basicas",
          },
          {
            id: 4,
            natural: "El cociente de {var1} sobre {var2}",
            algebraic: "{var1} ÷ {var2}",
            category: "operaciones_basicas",
          },
          {
            id: 5,
            natural: "La suma de los cuadrados de {var1} y {var2}",
            algebraic: "{var1}^2 + {var2}^2",
            category: "combinadas",
          },
        ],
      };

      // InicializaciÃ³n cuando se carga la pÃ¡gina
      document.addEventListener("DOMContentLoaded", function () {
        // Cargar patrones por defecto
        loadPatterns(defaultPatterns);

        // Configurar event listeners
        setupEventListeners();

        // Actualizar mÃ©tricas iniciales
        updateMetrics();
      });

      // Configurar todos los event listeners
      function setupEventListeners() {
        // Botones de conversiÃ³n
        document
          .getElementById("convert-to-algebraic-btn")
          .addEventListener("click", () => {
            convertNaturalToAlgebraic();
          });

        document
          .getElementById("convert-to-natural-btn")
          .addEventListener("click", () => {
            convertAlgebraicToNatural();
          });

        // Botones de evaluaciÃ³n - Columna Natural
        document
          .getElementById("natural-satisfactory-btn")
          .addEventListener("click", () => {
            markAsSatisfactory("natural");
          });

        document
          .getElementById("natural-improve-btn")
          .addEventListener("click", () => {
            markForImprovement("natural");
          });

        document
          .getElementById("natural-add-pattern-btn")
          .addEventListener("click", () => {
            showAddPatternDialog("natural");
          });

        // Botones de evaluaciÃ³n - Columna Algebraica
        document
          .getElementById("algebraic-satisfactory-btn")
          .addEventListener("click", () => {
            markAsSatisfactory("algebraic");
          });

        document
          .getElementById("algebraic-improve-btn")
          .addEventListener("click", () => {
            markForImprovement("algebraic");
          });

        document
          .getElementById("algebraic-add-pattern-btn")
          .addEventListener("click", () => {
            showAddPatternDialog("algebraic");
          });

        // Manejo de archivos JSON
        document
          .getElementById("json-file-input")
          .addEventListener("change", handleFileSelection);
        document
          .getElementById("load-json-btn")
          .addEventListener("click", loadJSONFile);
        document
          .getElementById("reset-json-btn")
          .addEventListener("click", resetToDefault);

        // Historial
        document
          .getElementById("clear-history-btn")
          .addEventListener("click", clearHistory);
        document
          .getElementById("export-history-btn")
          .addEventListener("click", exportHistory);
      }

      // FunciÃ³n para convertir lenguaje natural a algebraico
      function convertNaturalToAlgebraic() {
        const input = document.getElementById("natural-input").value.trim();
        if (!input) {
          alert("Por favor, ingresa una expresión en lenguaje natural");
          return;
        }

        const result = processNaturalToAlgebraic(input);
        displayResult("natural", input, result);

        // Actualizar estadÃ­sticas
        stats.totalConversions++;
        addToHistory("natural-to-algebraic", input, result);
        updateMetrics();
      }

      // FunciÃ³n para convertir algebraico a lenguaje natural
      function convertAlgebraicToNatural() {
        const input = document.getElementById("algebraic-input").value.trim();
        if (!input) {
          alert("Por favor, ingresa una expresión algebraica");
          return;
        }

        const result = processAlgebraicToNatural(input);
        displayResult("algebraic", input, result);

        // Actualizar estadÃ­sticas
        stats.totalConversions++;
        addToHistory("algebraic-to-natural", input, result);
        updateMetrics();
      }

      // Procesar conversiÃ³n de natural a algebraico
      function processNaturalToAlgebraic(input) {
        if (!patternsData || !patternsData.patterns) {
          return "Error: No hay patrones cargados";
        }

        const normalizedInput = input.toLowerCase();

        // Buscar patrones que coincidan
        for (let pattern of patternsData.patterns) {
          const match = matchNaturalPattern(normalizedInput, pattern.natural);
          if (match.isMatch) {
            return substituteVariables(pattern.algebraic, match.variables);
          }
        }

        return "No se encontró un patrón coincidente. Considera agregar este caso a los patrones.";
      }

      // Procesar conversiÃ³n de algebraico a natural
      function processAlgebraicToNatural(input) {
        if (!patternsData || !patternsData.patterns) {
          return "Error: No hay patrones cargados";
        }

        const normalizedInput = normalizeAlgebraicExpression(input);

        // Buscar patrones que coincidan
        for (let pattern of patternsData.patterns) {
          const match = matchAlgebraicPattern(
            normalizedInput,
            pattern.algebraic
          );
          if (match.isMatch) {
            return substituteVariables(pattern.natural, match.variables);
          }
        }

        return "No se encontró un patrón coincidente. Considera agregar este caso a los patrones.";
      }

      // FunciÃ³n para hacer coincidir patrones de lenguaje natural

      function matchNaturalPattern(input, pattern) {
        // Convertir patrÃ³n a regex
        let regex = pattern.toLowerCase();
        const variables = {};
        let varCounter = 0;

        // Reemplazar variables con grupos de captura
        regex = regex.replace(/\{(\w+)\}/g, (match, varName) => {
          variables[varName] = varCounter++;
          return "([a-zA-Z0-9_]+)";
        });

        // Hacer que los espacios sean opcionales y flexibles
        regex = regex.replace(/\s+/g, "\\s*");
        regex = "^\\s*" + regex + "\\s*$";

        const regexPattern = new RegExp(regex);
        const match = input.match(regexPattern);

        if (match) {
          const extractedVars = {};
          for (let [varName, index] of Object.entries(variables)) {
            extractedVars[varName] = match[index + 1];
          }
          return { isMatch: true, variables: extractedVars };
        }

        return { isMatch: false, variables: {} };
      }

      function matchAlgebraicPattern(input, pattern) {
        let normalizedInput = normalizeAlgebraicExpression(input);
        let normalizedPattern = normalizeAlgebraicExpression(pattern);

        console.log("=== DEBUGGING MATCH ===");
        console.log("Pattern original:", pattern);
        console.log("Pattern normalizado:", normalizedPattern);
        console.log("Input normalizado:", normalizedInput);

        // Primero escapar caracteres especiales EXCEPTO las llaves
        let regex = normalizedPattern.replace(/[\+\-\*\^]/g, "\\$&");
        console.log("Después de escapar:", regex);

        // Luego reemplazar variables con grupos de captura
        const variables = {};
        let varCounter = 0;

        regex = regex.replace(/\{(\w+)\}/g, (match, varName) => {
          variables[varName] = varCounter++;
          console.log(
            `Variable encontrada: ${varName} en posición ${varCounter - 1}`
          );
          return "([a-zA-Z0-9_]+)";
        });

        regex = "^\\s*" + regex + "\\s*$";

        console.log("Regex final:", regex);
        console.log("Variables mapeadas:", variables);

        const regexPattern = new RegExp(regex);
        const match = normalizedInput.match(regexPattern);

        console.log("Match result:", match);
        console.log("=== END DEBUG ===");

        if (match) {
          const extractedVars = {};
          for (let [varName, index] of Object.entries(variables)) {
            extractedVars[varName] = match[index + 1];
          }
          return { isMatch: true, variables: extractedVars };
        }

        return { isMatch: false, variables: {} };
      }
      /*
function matchAlgebraicPattern(input, pattern) {
    let normalizedInput = normalizeAlgebraicExpression(input);
    let normalizedPattern = normalizeAlgebraicExpression(pattern);

    console.log('=== DEBUGGING MATCH ===');
    console.log('Pattern original:', pattern);
    console.log('Pattern normalizado:', normalizedPattern);
    console.log('Input original:', input);
    console.log('Input normalizado:', normalizedInput);

    const variables = {};
    let varCounter = 0;

    // Reemplazar variables con grupos de captura
    let regex = normalizedPattern.replace(/\{(\w+)\}/g, (match, varName) => {
        variables[varName] = varCounter++;
        console.log(`Variable encontrada: ${varName} en posición ${varCounter-1}`);
        return '([a-zA-Z0-9_]+)';
    });

    // Solo escapar caracteres especiales
    regex = regex.replace(/[\+\-\*\^]/g, '\\$&');
    regex = '^\\s*' + regex + '\\s*$';

    console.log('Regex final:', regex);
    console.log('Variables mapeadas:', variables);

    const regexPattern = new RegExp(regex);
    const match = normalizedInput.match(regexPattern);

    console.log('Match result:', match);
    console.log('=== END DEBUG ===');

    if (match) {
        const extractedVars = {};
        for (let [varName, index] of Object.entries(variables)) {
            extractedVars[varName] = match[index + 1];
        }
        return { isMatch: true, variables: extractedVars };
    }

    return { isMatch: false, variables: {} };
}
*/
      // Normalizar expresiones algebraicas
      function normalizeAlgebraicExpression(expr) {
        return expr
          .replace(/\s+/g, "") // Quitar espacios
          .replace(/²/g, "^2") // Convertir ² a ^2 (no Â²)
          .replace(/³/g, "^3") // Convertir ³ a ^3 (no Â³)
          .replace(/\*/g, "×") // Normalizar multiplicación (no Ã—)
          .replace(/\//g, "÷") // Normalizar división (no Ã·)
          .toLowerCase();
      }

      // Sustituir variables en el patrÃ³n
      function substituteVariables(template, variables) {
        let result = template;
        for (let [varName, value] of Object.entries(variables)) {
          const regex = new RegExp(`\\{${varName}\\}`, "g");
          result = result.replace(regex, value);
        }
        return result;
      }

      // Mostrar resultado en la interfaz
      function displayResult(column, input, result) {
        const resultSection = document.getElementById(`${column}-result`);
        const outputElement = document.getElementById(`${column}-output`);

        outputElement.textContent = result;
        resultSection.style.display = "block";
      }

      // Marcar como satisfactorio
      function markAsSatisfactory(column) {
        stats.satisfactoryConversions++;
        updateMetrics();

        // Feedback visual
        showFeedback(`Marcado como satisfactorio`, "success");

        // Ocultar la secciÃ³n de resultado despuÃ©s de un tiempo
        setTimeout(() => {
          document.getElementById(`${column}-result`).style.display = "none";
        }, 2000);
      }

      // Marcar para mejora
      function markForImprovement(column) {
        showFeedback(
          "Marcado para mejora. Considera agregar un nuevo patrón.",
          "warning"
        );
      }

      // Mostrar diÃ¡logo para agregar patrÃ³n
      function showAddPatternDialog(column) {
        const input = document.getElementById(
          `${column === "natural" ? "natural" : "algebraic"}-input`
        ).value;
        const output = document.getElementById(`${column}-output`).textContent;

        const naturalText = column === "natural" ? input : output;
        const algebraicText = column === "natural" ? output : input;

        const newNatural = prompt(
          "Expresión en lenguaje natural:",
          naturalText
        );
        if (!newNatural) return;

        const newAlgebraic = prompt("Expresión algebraica:", algebraicText);
        if (!newAlgebraic) return;

        const category =
          prompt("Categoría­a (opcional):", "personalizado") || "personalizado";

        addNewPattern(newNatural, newAlgebraic, category);
      }

      // Agregar nuevo patrÃ³n
      function addNewPattern(natural, algebraic, category = "personalizado") {
        if (!patternsData) {
          patternsData = { patterns: [] };
        }

        const newId =
          Math.max(...patternsData.patterns.map((p) => p.id || 0), 0) + 1;
        const newPattern = {
          id: newId,
          natural: natural,
          algebraic: algebraic,
          category: category,
        };

        patternsData.patterns.push(newPattern);
        stats.totalPatterns = patternsData.patterns.length;
        updateMetrics();

        showFeedback(
          `Nuevo patrón agregado: "${natural}" - "${algebraic}"`,
          "success"
        );
      }

      // Cargar patrones
      function loadPatterns(data) {
        patternsData = data;
        stats.totalPatterns = data.patterns ? data.patterns.length : 0;
        stats.lastUpdate = new Date().toLocaleString("es-ES", {
          day: "2-digit",
          month: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
        });
        updateMetrics();
      }

      // Manejar selecciÃ³n de archivo
      function handleFileSelection() {
        const fileInput = document.getElementById("json-file-input");
        const fileName = document.getElementById("file-name");
        const loadButton = document.getElementById("load-json-btn");

        if (fileInput.files.length > 0) {
          const file = fileInput.files[0];
          fileName.textContent = file.name;
          stats.fileSize = Math.round(file.size / 1024);
          loadButton.disabled = false;
        } else {
          fileName.textContent = "Ningún archivo seleccionado";
          stats.fileSize = 0;
          loadButton.disabled = true;
        }
        updateMetrics();
      }

      // Cargar archivo JSON
      function loadJSONFile() {
        const fileInput = document.getElementById("json-file-input");
        if (fileInput.files.length === 0) {
          alert("Por favor, selecciona un archivo JSON");
          return;
        }

        const file = fileInput.files[0];
        const reader = new FileReader();

        reader.onload = function (e) {
          try {
            const jsonData = JSON.parse(e.target.result);

            // Validar estructura del JSON
            if (!jsonData.patterns || !Array.isArray(jsonData.patterns)) {
              throw new Error(
                'El archivo JSON debe tener una propiedad "patterns" que sea un array'
              );
            }

            loadPatterns(jsonData);
            showFeedback(
              `Archivo cargado exitosamente: ${file.name}`,
              "success"
            );
          } catch (error) {
            alert(`Error al cargar el archivo: ${error.message}`);
          }
        };

        reader.readAsText(file);
      }

      // Resetear a patrones por defecto
      function resetToDefault() {
        if (
          confirm(
            "¿Estás seguro de que quieres resetear a los patrones por defecto?"
          )
        ) {
          loadPatterns(defaultPatterns);
          stats.fileSize = 0;
          document.getElementById("file-name").textContent =
            "Ningún archivo seleccionado";
          document.getElementById("json-file-input").value = "";
          showFeedback("Patrones reseteados a valores por defecto", "info");
        }
      }

      // Agregar al historial
      function addToHistory(type, input, output) {
        const historyItem = {
          timestamp: new Date().toLocaleString("es-ES"),
          type: type,
          input: input,
          output: output,
        };

        conversionHistory.unshift(historyItem); // Agregar al inicio
        if (conversionHistory.length > 50) {
          // Limitar historial
          conversionHistory.pop();
        }

        updateHistoryDisplay();
      }

      // Actualizar visualizaciÃ³n del historial
      function updateHistoryDisplay() {
        const historyContainer = document.getElementById("conversion-history");

        if (conversionHistory.length === 0) {
          historyContainer.innerHTML =
            '<p class="no-history">No hay conversiones realizadas aún</p>';
          return;
        }

        const historyHTML = conversionHistory
          .map(
            (item) => `
        <div class="history-item">
            <div class="history-header">
                <span class="history-type">${item.type === "natural-to-algebraic" ? "Natural a Algebraico" : "Algebraico a Natural"}</span>
                <span class="history-timestamp">${item.timestamp}</span>
            </div>
            <div class="history-content">
                <div><strong>Entrada:</strong> ${item.input}</div>
                <div><strong>Resultado:</strong> ${item.output}</div>
            </div>
        </div>
    `
          )
          .join("");

        historyContainer.innerHTML = historyHTML;
      }

      // Limpiar historial
      function clearHistory() {
        if (confirm("¿Estás seguro de que quieres limpiar el historial?")) {
          conversionHistory = [];
          updateHistoryDisplay();
          showFeedback("Historial limpiado", "info");
        }
      }

      // Exportar historial
      function exportHistory() {
        if (conversionHistory.length === 0) {
          alert("No hay historial para exportar");
          return;
        }

        const dataStr = JSON.stringify(conversionHistory, null, 2);
        const dataBlob = new Blob([dataStr], { type: "application/json" });

        const link = document.createElement("a");
        link.href = URL.createObjectURL(dataBlob);
        link.download = `historial_conversiones_${new Date().toISOString().split("T")[0]}.json`;
        link.click();

        showFeedback("Historial exportado exitosamente", "success");
      }

      // Actualizar mÃ©tricas en la interfaz
      function updateMetrics() {
        document.getElementById("total-patterns").textContent =
          stats.totalPatterns;
        document.getElementById("file-size").textContent =
          stats.fileSize > 0 ? `${stats.fileSize} KB` : "0 KB";
        document.getElementById("conversions-count").textContent =
          stats.totalConversions;

        // Calcular tasa de satisfacciÃ³n
        const satisfactionRate =
          stats.totalConversions > 0
            ? Math.round(
                (stats.satisfactoryConversions / stats.totalConversions) * 100
              )
            : 0;
        document.getElementById("satisfaction-rate").textContent =
          `${satisfactionRate}%`;

        document.getElementById("last-update").textContent =
          stats.lastUpdate || "--";

        // Calcular complejidad promedio
        const avgComplexity = calculateAverageComplexity();
        document.getElementById("avg-complexity").textContent = avgComplexity;
      }

      // Calcular complejidad promedio
      function calculateAverageComplexity() {
        if (
          !patternsData ||
          !patternsData.patterns ||
          patternsData.patterns.length === 0
        ) {
          return 0;
        }

        const totalWords = patternsData.patterns.reduce((sum, pattern) => {
          const wordCount = pattern.natural.split(" ").length;
          return sum + wordCount;
        }, 0);

        return Math.round(totalWords / patternsData.patterns.length);
      }

      // Mostrar feedback al usuario
      function showFeedback(message, type = "info") {
        // Crear elemento de feedback si no existe
        let feedbackElement = document.getElementById("feedback-message");
        if (!feedbackElement) {
          feedbackElement = document.createElement("div");
          feedbackElement.id = "feedback-message";
          feedbackElement.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem;
            border-radius: 4px;
            color: white;
            font-weight: 600;
            z-index: 1000;
            transition: opacity 0.3s ease;
        `;
          document.body.appendChild(feedbackElement);
        }

        // Configurar estilos segÃºn el tipo
        const colors = {
          success: "#10b981",
          error: "#ef4444",
          warning: "#f59e0b",
          info: "#3b82f6",
        };

        feedbackElement.style.backgroundColor = colors[type] || colors["info"];
        feedbackElement.textContent = message;
        feedbackElement.style.opacity = "1";

        // Ocultar despuÃ©s de 3 segundos
        setTimeout(() => {
          feedbackElement.style.opacity = "0";
        }, 3000);
      }
    </script>
  </body>
</html>
